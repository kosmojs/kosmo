import { access, chmod, constants, readFile, unlink } from "node:fs/promises";
import http, { type IncomingMessage, type ServerResponse } from "node:http";
import { extname, join, relative, resolve } from "node:path";
import { parseArgs } from "node:util";

import type { SSRSetup, SSRManifestEntry } from "@kosmojs/dev";

import { baseurl } from "{{ createImport "config" }}";
import { match } from "./path-to-regexp";

/**
 * Root directory where Vite client assets are emitted.
 * This is used both for serving static files and for reading index.html + manifest.
 * */
const STATIC_DIR = resolve(import.meta.dirname, "../client");

const REDIRECT_CODES = [
  301, // Moved Permanently
  302, // Found (temporary)
  303, // See Other (redirect after POST)
  307, // Temporary Redirect (preserves method)
  308, // Permanent Redirect (preserves method)
];

type AssetInfo = {
  // Raw file contents kept in memory for fast, zero-I/O responses.
  // Can be undefined if `serveStaticAssets` option is false.
  buffer: Buffer | undefined;
  // HTTP Content-Type header for this asset (derived from extension).
  contentType: string;
  // Cached size to set Content-Length without re-measuring the buffer.
  size: number;
}

type Manifest = Record<string, SSRManifestEntry>;

type ResolvedAsset = {
  kind: "js" | "css" | "asset";
  path: string;
  // All manifest paths that uses this asset
  use: Set<string>;
};

/**
 * Pre-computed route matchers for efficient URL-to-asset resolution.
 * */
const routeMap: Array<{
  // path-to-regexp matcher function that tests if a URL matches this route
  match: (path: string) => boolean;

  // Route file path used to search within cssAssets.use entries.
  // Each CSS asset has a `use` property - a set of route files that import it.
  // This enables identifying CSS assets used by the current route for critical CSS.
  file: string;

  // Layout chain - ordered array of layouts wrapping this route.
  // Used to identify CSS assets imported by each layout.
  // This enables adding layout CSS to critical CSS for the current route.
  layouts: Array<string>;
}> = [
  {{#each routeMap}}
  {
    match: match("{{path}}"),
    file: "{{file}}",
    layouts: [ {{#each layouts}}"{{.}}", {{/each}}],
  },
  {{/each}}
];

const criticalCssOrder: Record<"global" | "layout" | "index", number> = {
  global: 1,
  layout: 2,
  index: 3,
};

export const requestHandlerFactory = ({
  template,
  ssrSetup,
  cssAssets,
  assetCache,
  manifest,
}: {
  // index.html from client build (contains <!--app-head--> and <!--app-html-->)
  template: string;
  // user-provided SSR factory
  ssrSetup: SSRSetup;
  // resolved CSS assets with guaranted `text` property for inlining
  cssAssets: Array<ResolvedAsset & { text: string }>;
  // a map of all built assets (for serving static files)
  assetCache: Map<string, AssetInfo>;
  // raw Vite manifest.json for advanced SSR uses
  manifest: Manifest;
}) => {
  return async (
    request: IncomingMessage,
    response: ServerResponse,
  ) => {
    // If Node's IncomingMessage somehow lacks URL, treat as a server error.
    if (request.url === undefined) {
      response.writeHead(500, { "Content-Type": "text/html" });
      response.end("<h1>500 · Server Error</h1>");
      return;
    }

    // Normalize the request URL into a pathname to match against routes.
    const { pathname } = new URL(request.url, `http://${request.headers.host}`);

    // Strip baseurl to get the internal route path.
    const path = relative(baseurl, pathname);

    // If incoming request path matches something cached at startup, serve it directly.
    // This covers JS, CSS, images, fonts, etc., including their .map siblings.
    const asset = assetCache.get(path);

    if (asset) {
      if (asset.buffer) {
        response.writeHead(200, {
          "Content-Type": asset.contentType,
          "Content-Length": asset.size,
        });
        response.end(asset.buffer);
      } else {
        // file could not be read or `serveStaticAssets` option is false
        response.writeHead(404, { "Content-Type": "text/html" });
        response.end("<h1>404 · Not Found</h1>");
      }
      return;
    }

    // Match incoming request path (e.g., "/products/123") against
    // pre-compiled route patterns (e.g., "/products/:id")
    const route = routeMap.find(({ match }) => match(path));

    if (!route) {
      // not a static file and no route matched, return 404
      response.writeHead(404, { "Content-Type": "text/html" });
      response.end("<h1>404 · Not Found</h1>");
      return;
    }

    // There is a route matched, prepare response for SSR pipelines.
    response.writeHead(200, {
      "Content-Type": "text/html",
      "Transfer-Encoding": "chunked",
    });

    // Collect critical CSS for the matched route.
    const criticalCss = cssAssets
      .flatMap(({ text, path, use }) => {
        // CSS assets referenced by index.html entrypoint are always critical,
        // regardless incoming request path
        let kind: keyof typeof criticalCssOrder | undefined = manifest[
          "index.html"
        ]?.css?.includes(path)
          ? "global"
          : undefined;

        if (use.has(route.file)) {
          // Imported by the current route
          kind = "index";
        } else if (route.layouts.some((e) => use.has(e))) {
          // Imported by any layout wrapping current route
          kind = "layout";
        }

        return kind ? [{ text, path: join(baseurl, path), kind }] : [];
      })
      .sort((a, b) => criticalCssOrder[a.kind] - criticalCssOrder[b.kind]);

    try {
      // Ask the user-provided SSR factory to produce rendering methods
      const { renderToString, renderToStream } = ssrSetup;
      const url = new URL(request.url, `http://${request.headers.host}`);

      if (renderToStream) {
        // Mode 1: streaming SSR.
        //
        // - renderToStream is responsible for writing HTML chunks into `response`.
        // - Provided renderer can decide when to:
        //     - start the shell,
        //     - flush critical chunks,
        //     - hydrate with client-side routes/assets.
        // - The renderer **must call `response.end()`** when streaming is finished,
        //   otherwise the HTTP request will remain open and the client will hang.
        //
        // This gives frameworks full control for advanced streaming strategies
        // (e.g., suspense boundaries, progressive hydration, selective re-render).
        await renderToStream(url, {
          template,
          manifest,
          criticalCss,
          request,
          response,
        });
        return;
      }

      if (renderToString) {
        // Mode 2: string-based SSR.
        //
        // - renderToString() returns { head, html } for the current route.
        // - Splice that into the Vite-generated index.html template by replacing:
        //   - <!--app-head--> with collected head tags (CSS + optional user head)
        //   - <!--app-html--> with the app HTML markup
        //
        // This mode is simple and works well when you don't need streaming.
        const [htmlStart, htmlEnd] = template.split("<!--app-html-->");
        const { head, html } = await renderToString(url, {
          template,
          manifest,
          criticalCss,
          request,
          response,
        });
        response.write(htmlStart.replace("<!--app-head-->", head ?? ""));
        response.write(html);
        response.write(htmlEnd);
        response.end();
        return;
      }

      // SSR factory returned neither mode
      response.writeHead(501, { "Content-Type": "text/html" });
      response.end("<h1>501 · Not Implemented</h1>");
    } catch (error) {
      // Handle thrown Response instances as redirects.
      // Re-throw other errors for upstream handling.
      if (error instanceof Response) {
        const Location = error.headers.get("Location");

        if (!Location || !REDIRECT_CODES.includes(error.status)) {
          response.writeHead(500, { "Content-Type": "text/html" });
          response.end("<h1>500 · Malformed redirect</h1>");
          return;
        }

        response.writeHead(error.status, { Location });
        response.end();
        return;
      }
      throw error;
    }
  };
};

/**
 * Traverse Vite's manifest graph and build a plain asset list.
 * */
const resolveAssets = (manifest: Manifest): Array<ResolvedAsset> => {
  const traverse = (
    key: string,
    entry: SSRManifestEntry,
    data: {
      resolvedAssets: Record<string, ResolvedAsset>;
      visiting: Set<string>;
      use: Set<string>;
    },
  ): Record<string, ResolvedAsset> => {
    // Protect against cyclic graphs (just in case Rollup creates loops).
    if (data.visiting.has(key)) {
      return data.resolvedAssets;
    }

    const visiting = new Set(data.visiting).add(key);

    // Start with a copy of resolvedAssets
    const resolvedAssets = { ...data.resolvedAssets };

    const use = new Set([ ...data.use, key ]);

    const createAsset = (path: string, kind: ResolvedAsset["kind"]) => {
      return {
        kind,
        path,
        // Each step extends the list of manifest paths that "use" this entry
        use: new Set([
          ...(resolvedAssets[path]?.use || []),
          ...use,
        ]),
      }
    };

    // Register JS assets produced by this manifest entry.
    if (entry.file?.endsWith(".js")) {
      resolvedAssets[entry.file] = createAsset(entry.file, "js");
    }

    // Register any CSS chunks associated with this entry.
    for (const path of entry.css || []) {
      resolvedAssets[path] = createAsset(path, "css");
    }

    // Register any additional assets (images, fonts, etc.).
    for (const path of entry.assets || []) {
      resolvedAssets[path] = createAsset(path, "asset");
    }

    // Recursively traverse both static and dynamic imports to propagate ancestry.
    for (const key of [
      ...(entry.imports || []),
      ...(entry.dynamicImports || []),
    ]) {
      // Skip Vite's synthetic index.html key; it's not a real module.
      const entry = key === "index.html" ? undefined : manifest[key];
      if (entry) {
        Object.assign(
          resolvedAssets,
          traverse(key, entry, {
            resolvedAssets,
            visiting,
            use,
          }),
        );
      }
    }

    return resolvedAssets;
  };

  const resolvedAssets = Object.entries(manifest).reduce(
    (resolvedAssets: Record<string, ResolvedAsset>, [key, entry]) => {
      return traverse(key, entry, {
        resolvedAssets,
        visiting: new Set(),
        use: new Set(),
      });
    },
    {},
  );

  return Object.values(resolvedAssets);
};

/**
 * Build an in-memory asset graph from the resolved Vite manifest entries,
 * optionally loading asset content into memory depending on deployment mode.
 *
 * The asset graph always includes every built asset URL so the SSR server
 * can correctly:
 *   • recognize static asset requests,
 *   • return 404 when `serveStaticAssets === false`,
 *   • and support inline CSS even when other assets are externally served.
 *
 * Behavior depends on `loadIntoMemory` (mirrors SSR option `serveStaticAssets`):
 *
 *   loadIntoMemory = true   (default)
 *     → All assets produced by the build (JS, CSS, images, fonts, …)
 *       are read into memory as Buffers at server startup.
 *     → The SSR server is fully responsible for serving static assets.
 *     → Fastest per-request performance (no filesystem I/O).
 *
 *   loadIntoMemory = false
 *     → Only CSS files are read (so SSR can inline critical CSS).
 *     → All other asset URLs are still registered in the cache,
 *       but with *no* Buffer content.
 *     → Browser requests to those asset URLs will return `404`
 *       unless served by a proxy/CDN/static host.
 *     → Ideal when a reverse proxy is expected to serve static assets.
 *
 * */
export const loadAssets = async (
  resolvedAssets: Array<ResolvedAsset>,
  loadIntoMemory: boolean,
) => {
  const mimeTypeMap: Record<string, string> = {
    ".js": "application/javascript",
    ".mjs": "application/javascript",
    ".css": "text/css",
    ".json": "application/json",
    ".png": "image/png",
    ".apng": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".svg": "image/svg+xml",
    ".ico": "image/x-icon",
    ".woff": "font/woff",
    ".woff2": "font/woff2",
    ".ttf": "font/ttf",
    ".webp": "image/webp",
  };

  // Resolve HTTP Content-Type from the asset's file extension.
  const contentTypeResolver = (filePath: string) => {
    const ext = extname(filePath).toLowerCase();
    return mimeTypeMap[ext] || "application/octet-stream";
  };

  // Map from URL path (as used in requests) to asset metadata.
  const assetCache = new Map<string, AssetInfo>();

  // Load files into memory at server start (unless loadIntoMemory is false).
  await Promise.all(
    resolvedAssets.map(async ({ kind, path }) => {
      const filePath = resolve(STATIC_DIR, path);

      const buffer =
        loadIntoMemory || kind === "css" // css loaded anyway
          ? await readFile(filePath)
          : undefined;

      assetCache.set(path, {
        buffer,
        contentType: contentTypeResolver(filePath),
        size: buffer?.length || 0,
      });

      // Attempt to preload sourcemaps for JS/CSS as well (if they exist).
      if (/.(m?js|css)$/i.test(filePath)) {
        try {
          await access(`${filePath}.map`, constants.F_OK);
          const buffer = loadIntoMemory //
            ? await readFile(`${filePath}.map`)
            : undefined;
          assetCache.set(`${path}.map`, {
            buffer,
            contentType: "application/json",
            size: buffer?.length || 0,
          });
        } catch {
          return;
        }
      }
    }),
  );

  return assetCache;
};

/**
 * Bootstraps the HTTP server:
 * - reads the HTML template (Vite client index.html)
 * - loads the SSR bundle (app.js)
 * - imports Vite's manifest.json
 * - resolves assets
 * - wires everything into an http.createServer handler
 *
 * Export the server factory so tests or higher-level tools can use it if needed.
 * */
export const createServer = async () => {

  // Read the client index.html that includes <!--app-head--> and <!--app-html-->
  // placeholders used for SSR injection.
  const template = await readFile(resolve(STATIC_DIR, "index.html"), "utf8");

  // Import the SSR entry produced by Vite's ssr build.
  const ssrSetup: SSRSetup = await import(
    resolve(import.meta.dirname, "app.js")
  ).then((e) => e.default);

  // Load the Vite manifest so we can understand the final asset graph.
  const manifest: Manifest = await import(
    resolve(STATIC_DIR, ".vite/manifest.json"),
    { with: { type: "json" } }
  ).then((e) => e.default);

  // Turn the manifest into ResolvedAsset records with dependency paths.
  const resolvedAssets = resolveAssets(manifest);

  // Read all assets from disk into an in-memory cache (Buffers).
  const assetCache = await loadAssets(
    resolvedAssets,
    "serveStaticAssets" in ssrSetup ? ssrSetup.serveStaticAssets : true,
  );

  // Create the HTTP server using the factory configured above.
  // For CSS assets also precompute their text form for inlining.
  const server = http.createServer(
    requestHandlerFactory({
      template,
      ssrSetup,
      // provide only css assets and only ones with a valid cache.
      cssAssets: resolvedAssets.flatMap(({ kind, path, ...rest }) => {
        const cache = kind === "css" ? assetCache.get(path) : undefined;
        // Decode CSS once at startup so SSR can inline
        // without calling toString() on every request.
        return cache?.buffer
          ? [{ kind, path, text: cache.buffer.toString(), ...rest }]
          : [];
      }),
      assetCache,
      manifest,
    }),
  );

  return server;
};

/**
 * Parse CLI arguments so this file can be used both as a module
 * and a standalone executable
 * */
const { values: { port, sock } } = parseArgs({
  options: {
    port: {
      type: "string",
      short: "p",
    },
    sock: {
      type: "string",
      short: "s",
    },
  },
});

/**
 * If either a TCP port or a Unix socket is provided, start listening.
 * */
if (port || sock) {
  if (sock) {
    // Clean up any stale socket file before binding.
    await unlink(sock).catch((error) => {
      if (error.code === "ENOENT") {
        return;
      }
      console.error(error.message);
      process.exit(1);
    });
  }

  console.log("\n  ➜ Loading Assets");

  const server = await createServer();

  console.log("\n  ➜ Starting Server", { port, sock });

  server.listen(port || sock, async () => {
    if (sock) {
      // Make Unix socket world-writable so other processes (e.g. a parent runner)
      // can connect without permission issues.
      await chmod(sock, 0o777);
    }
    console.log("\n  ➜ Server Started ✨");
  });
}
