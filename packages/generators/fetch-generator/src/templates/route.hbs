import fetchFactory, {
  type HostOpt,
  join,
  stringify,
  createHost,
} from "@kosmojs/fetch";

import { baseurl, apiurl } from "{{ createImport "config" }}";
{{#if runtimeValidation}}
import { validationSchemas } from "{{ createImport "libApi" route.name "schemas" }}";
{{/if}}

import {
  type MaybeWrapped,
  unwrap,
} from "{{ createImport "lib" "unwrap" }}";

import { fetchClientFactory } from "{{ createImport "lib" "fetch:lib" }}";

import type {
  {{route.params.id}},
{{#each validationTypes}}  {{id}},
{{/each}}
} from "{{ createImport "libApi" route.name "types" }}";

export { ValidationError } from "@kosmojs/api/errors";

export type ParamsT = [
  {{createParamsLiteral route.params}}
];

{{#each payloadTypes}}
export type {{name}} = {
  {{#each types}}{{method}}: {{id}};
  {{/each}}
}
{{/each}}

export type ResponseT = {
  {{#each responseTypes}}
  {{method}}: {{#each types}}{{#unless @first}}|{{/unless}} {{id}}{{/each}};
  {{/each}}
}

const { paramsMapper, parametrize } = fetchClientFactory({{serializeRoute route}});

const fetchApi = fetchFactory(join(baseurl, apiurl), { stringify });

{{#each routeMethods}}
export const {{method}} = (
  _params{{#if ../route.optionalParams}}?{{/if}}: MaybeWrapped<ParamsT>,
  _payload?: {
    {{#each ../payloadTypes}}
    {{target}}: {{name}} extends { {{../method}}: unknown }
      ? MaybeWrapped<{{name}}["{{../method}}"]>
      : unknown,
    {{/each}}
  }
): Promise<
  {{#if responseType}}
  ResponseT["{{method}}"]
  {{else}}
  unknown
  {{/if}}
> => {
  const params = unwrap<ParamsT>(_params || []);
  {{#if ../runtimeValidation}}
  if (validationSchemas.params) {
    validationSchemas.params.validate(paramsMapper(params));
  }
  {{#each payloadTypes}}
  if (validationSchemas.{{target}}?.{{../method}}) {
    validationSchemas.{{target}}.{{../method}}.validate(
      _payload?.["{{target}}"]
    );
  }
  {{/each}}
  {{/if}}
  return fetchApi.{{method}}(parametrize(params), _payload as never);
};
{{/each}}

export const path = (
  params: ParamsT,
  query?: Record<string, unknown>,
) => {
  const path = join(
    baseurl,
    {{#if route.base}}"{{route.base}}"{{else}}apiurl{{/if}},
    parametrize(params)
  );
  return query
    ? [ path, stringify(query) ].join("?")
    : path;
}

export const href = (
  host: HostOpt,
  params: ParamsT,
  query?: Record<string, unknown>,
) => createHost(host) + path(params, query);

export default {
  {{#each routeMethods}}
  {{method}},
  {{/each}}
  path,
  href,
  {{#if runtimeValidation}}
  validationSchemas,
  {{/if}}
};
