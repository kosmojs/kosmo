import fetchFactory, {
  type HostOpt,
  join,
  stringify,
  createHost,
} from "@kosmojs/fetch";

import { baseurl, apiurl } from "{{ createImport "config" }}";
{{#if runtimeValidation}}
import { validationSchemas } from "{{ createImport "libApi" route.name "schemas" }}";
{{/if}}

import {
  type MaybeWrapped,
  unwrap,
} from "{{ createImport "lib" "unwrap" }}";

import type {
  {{route.params.id}},
{{#each validationTypes}}  {{id}},
{{/each}}
} from "{{ createImport "libApi" route.name "types" }}";

export { ValidationError } from "@kosmojs/api/errors";

export type ParamsT = [
  {{#each route.params.schema}}
  {{#if isRest}}
  ...{{const}}: Array<string | number>
  {{else}}
  {{const}}{{#unless isRequired}}?{{/unless}}: {{../route.params.id}}["{{name}}"],
  {{/if}}
  {{/each}}
];

{{#each payloadTypes}}
export type {{name}} = {
  {{#each types}}{{method}}: {{id}};
  {{/each}}
}
{{/each}}

export type ResponseT = {
  {{#each responseTypes}}
  {{method}}: {{#each types}}{{#unless @first}}|{{/unless}} {{id}}{{/each}};
  {{/each}}
}

const paramsMapper = (params: ParamsT) => {
  return {
    {{#each paramsMapper}}
    {{#if isRest}}
      "{{name}}": params.slice({{idx}}),
    {{else if isOptional}}
      ...params[{{idx}}] ? { "{{name}}": params[{{idx}}] } : {},
    {{else}}
      "{{name}}": params[{{idx}}],
    {{/if}}
    {{/each}}
  }
}

const pathTokens: Array<[ path: string, param?: { isRest: boolean } ]> = [
  {{#each route.pathTokens}}
  [
    "{{path}}",{{#if param}}
    { isRest: {{#if param.isRest}}true{{else}}false{{/if}} }{{/if}}
  ],
  {{/each}}
];

const parametrize = (params: ParamsT) => {
  const paramsClone = structuredClone(params);
  return pathTokens
    .flatMap(([ path, param ]) => {
      if (param?.isRest) {
        return paramsClone;
      }
      if (param) {
        return paramsClone.splice(0, 1);
      }
      return [path];
    })
    .join("/");
}

const fetchApi = fetchFactory(join(baseurl, apiurl), { stringify });

{{#each routeMethods}}
export const {{method}} = (
  _params{{#if ../route.optionalParams}}?{{/if}}: MaybeWrapped<ParamsT>,
  _payload?: {
    {{#each ../payloadTypes}}
    {{target}}: {{name}} extends { {{../method}}: unknown }
      ? MaybeWrapped<{{name}}["{{../method}}"]>
      : unknown,
    {{/each}}
  }
): Promise<
  {{#if responseType}}
  ResponseT["{{method}}"]
  {{else}}
  unknown
  {{/if}}
> => {
  const params = unwrap(_params || []);
  {{#if ../runtimeValidation}}
  if (validationSchemas.params) {
    validationSchemas.params.validate(paramsMapper(params as never));
  }
  {{#each payloadTypes}}
  if (validationSchemas.{{target}}?.{{../method}}) {
    validationSchemas.{{target}}.{{../method}}.validate(
      _payload?.["{{target}}"]
    );
  }
  {{/each}}
  {{/if}}
  return fetchApi.{{method}}(parametrize(params as never), _payload as never);
};
{{/each}}

export const path = (
  params: ParamsT,
  query?: Record<string, unknown>,
) => {
  const path = join(
    baseurl,
    {{#if route.base}}"{{route.base}}"{{else}}apiurl{{/if}},
    parametrize(params)
  );
  return query
    ? [ path, stringify(query) ].join("?")
    : path;
}

export const href = (
  host: HostOpt,
  params: ParamsT,
  query?: Record<string, unknown>,
) => createHost(host) + path(params, query);

export default {
  {{#each routeMethods}}
  {{method}},
  {{/each}}
  path,
  href,
  {{#if runtimeValidation}}
  validationSchemas,
  {{/if}}
};
