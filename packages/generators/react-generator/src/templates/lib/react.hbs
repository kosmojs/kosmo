import {
  type HostOpt,
  createHost,
  stringify,
  join,
} from "@kosmojs/fetch";

import { baseurl } from "{{ createImport "config" }}";

{{#each apiRoutes}}
import type { ResponseT as {{id}} } from "{{ createImport "fetch" name }}";
{{/each}}

export const ssrMode = () => {{ssrMode}};

export type ComponentLoader = () => Promise<{
  loader?: (arg: unknown) => Promise<unknown>;
}>;

export const loaderFactory = (opt?: { withPreload?: boolean }) => {
  return (componentLoader: ComponentLoader) => {
    const loader = async (arg: unknown) => {
      try {
        const component = await componentLoader();
        return typeof component.loader === "function"
          ? component.loader(arg)
          : undefined;
      } catch (error) {
        console.error(error);
        return;
      }
    };
    return opt?.withPreload ? { loader } : {};
  };
};

export const pageFactory = <ParamsT>(
  pathTokens: Array<[ path: string, param?: { isRest: boolean } ]>
) => {
  type QueryT = Record<string, unknown>;

  return {
    parametrize(params: ParamsT) {
      const paramsClone = structuredClone(params) as Array<string>;
      return pathTokens
        .flatMap(([ path, param ]) => {
          if (param?.isRest) {
            return paramsClone;
          }
          if (param) {
            return paramsClone.splice(0, 1);
          }
          return [path];
        })
        .join("/");
    },

    base(
      params: ParamsT,
      query?: QueryT,
    ) {
      const base = join("/", this.parametrize(params));
      return query
        ? [ base, stringify(query) ].join("?")
        : base;
    },

    path(
      params: ParamsT,
      query?: QueryT,
    ) {
      return join(baseurl, this.base(params, query));
    },

    href(
      host: HostOpt,
      params: ParamsT,
      query?: QueryT,
    ) {
      return createHost(host) + this.path(params, query);
    },
  }
};
